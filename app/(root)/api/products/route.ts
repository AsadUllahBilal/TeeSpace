import { NextRequest, NextResponse } from 'next/server';
import { writeFile, unlink } from 'fs/promises';
import path from 'path';
import { v2 as cloudinary } from 'cloudinary';
import Product from '@/models/Product';
import Category from '@/models/Category'; // Import Category model
import connectDB from '@/lib/mongo';

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// Helper function to parse form data
async function parseFormData(request: NextRequest) {
  const formData = await request.formData();
  const entries = Array.from(formData.entries());
  
  const fields: Record<string, any> = {};
  const files: File[] = [];
  
  for (const [key, value] of entries) {
    if (value instanceof File) {
      files.push(value);
    } else {
      if (fields[key]) {
        if (Array.isArray(fields[key])) {
          fields[key].push(value);
        } else {
          fields[key] = [fields[key], value];
        }
      } else {
        fields[key] = value;
      }
    }
  }
  
  return { fields, files };
}

// Helper function to upload file to Cloudinary
async function uploadToCloudinary(file: File) {
  try {
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    
    // Create a temporary file
    const tempDir = path.join(process.cwd(), 'temp');
    // Ensure temp directory exists
    try {
      await unlink(tempDir); // Try to remove if it's a file
    } catch (e) {
      // Directory doesn't exist or is already a directory
    }
    try {
      await writeFile(tempDir, '', { flag: 'wx' }); // Try to create directory
    } catch (e) {
      // Directory already exists
    }
    
    const tempPath = path.join(tempDir, file.name);
    await writeFile(tempPath, buffer);
    
    // Upload to Cloudinary
    const result = await cloudinary.uploader.upload(tempPath, {
      folder: 'products',
    });
    
    // Clean up temporary file
    await unlink(tempPath);
    
    return result.secure_url;
  } catch (error) {
    console.error('Error uploading to Cloudinary:', error);
    throw error;
  }
}

export async function POST(request: NextRequest) {
  try {
    await connectDB();
    
    const { fields, files } = await parseFormData(request);

    // Extract form data
    const title = fields.title || '';
    const description = fields.description || '';
    const price = parseFloat(fields.price?.toString() || '0');
    const category = fields.category || '';
    const colors = typeof fields.colors === 'string' ? JSON.parse(fields.colors) : [];
    const sizes = typeof fields.sizes === 'string' ? JSON.parse(fields.sizes) : [];
    const stockQuantity = parseInt(fields.stockQuantity?.toString() || '0');
    const reviews = parseInt(fields.reviews || {});
    
    // Upload images
    let imageUrls: string[] = [];
    if (files.length > 0) {
      const uploadPromises = files.map(async (file) => {
        try {
          return await uploadToCloudinary(file);
        } catch (error) {
          console.error('Error uploading image:', error);
          return null;
        }
      });

      imageUrls = (await Promise.all(uploadPromises)).filter(url => url !== null);
    }

    // Create new product (slug will be auto-generated by the pre-save hook)
    const product = new Product({
      title,
      description,
      price,
      category,
      colors,
      sizes,
      stockQuantity,
      reviews,
      images: imageUrls,
    });

    // Ensure slug is generated before saving
    if (!product.slug && product.title) {
      const { generateSlug } = await import('@/lib/slug');
      let baseSlug = generateSlug(product.title);
      let slug = baseSlug;
      let counter = 1;
      
      // Check if slug already exists
      while (await Product.findOne({ slug })) {
        slug = `${baseSlug}-${counter}`;
        counter++;
      }
      
      product.slug = slug;
    }

    await product.save();
    await product.populate('category');

    return NextResponse.json({
      success: true,
      data: product,
    }, { status: 201 });
  } catch (error) {
    console.error('Error creating product:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to create product' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    await connectDB();

    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get("limit") || "10");
    const page = parseInt(searchParams.get("page") || "1");
    const category = searchParams.get("category");
    const search = searchParams.get("search");
    const color = searchParams.get("color");
    const minPrice = searchParams.get("min_price");
    const maxPrice = searchParams.get("max_price");

    // Build query
    let query: any = {};

    if (category) {
      query.category = category;
    }

    if (search) {
      query.$or = [
        { title: { $regex: search, $options: "i" } },
        { description: { $regex: search, $options: "i" } },
      ];
    }

    if (color) {
      // Support multiple colors -> ?color=green,black
      const colors = color.split(",");
      query.color = { $in: colors };
    }

    if (minPrice || maxPrice) {
      query.price = {};
      if (minPrice) query.price.$gte = Number(minPrice);
      if (maxPrice) query.price.$lte = Number(maxPrice);
    }

    const products = await Product.find(query)
      .populate("category")
      .limit(limit)
      .skip((page - 1) * limit)
      .sort({ createdAt: -1 });

    const total = await Product.countDocuments(query);

    return NextResponse.json({
      success: true,
      data: products,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error("Error fetching products:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch products" },
      { status: 500 }
    );
  }
}